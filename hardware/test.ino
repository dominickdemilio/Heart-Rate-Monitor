Dom
        dominickdemilio
            Invisible

                A wild reece appeared. — 12 /
    8 / 24,
    10 : 32 AM
            Everyone welcome Dom ! — 12 /
        8 / 24,
    11 : 07 AM
            Dom is here. — 12 /
        8 / 24,
    11 : 09 AM
            Collin Kruger — 12 /
        8 / 24,
    12 : 06 PM
            Termius
                reece — 12 /
        8 / 24,
    12 : 07 PM
            r.chambers.iv @icloud.com
                Collin Kruger — 12 /
        8 / 24,
    12 : 08 PM
            Ckruger @me.com
                Collin Kruger — 12 /
        14 / 24,
    11 : 37 AM const express = require('express');
const cors = require('cors');   // Import CORS middleware
const axios = require('axios'); // Import axios for Particle API requests
const app = express();

// Generate a random API Key
Expand
            app.js 3 KB
                here s my app.js
                    Collin Kruger — Today at 4 : 40 PM
                        code-- -- -BEGIN RSA PRIVATE KEY-- -- -MIIJKQIBAAKCAgEAr5b3XarsBUXmhQlbuuncUEyeOLPYV3hWnSkLSaAV /
        wx / Fis6 4JDJ +
    hCc5X66ZBvufB4R0t + gMSA5LTsf / KQ4thp / OoxR35vASTfk7csNtsGXBjbr 0ktTDTLFqolS5OTWdyTPMvi9hlevE5hCRqfxMc9k88bLbPBZgZOmGoGpX6htVCMo Bj0DjJUO / Oe / Y1FADQozN8CTlvxiRnsHxAHMQ6Jy5H2EC89F5DhQyWh6sXI5B4Nv Uqg9vgvemLkJv5wJ1OkSVOjorq25 + UygMlkOP / 5Ng8c7Q44mLHsS7YCNGXWTcAm8 Expand message.txt 4 KB ssh - rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCvlvddquwFReaFCVu66dxQTJ44s9hXeFadKQtJoBX / DH8WKzrgkMn6EJzlfrpkG + 58HhHS36AxIDktOx / 8pDi2Gn86jFHfm8BJN + Ttyw22wZcGNuvSS1MNMsWqiVLk5NZ3JM8y + L2GV68TmEJGp / Exz2Tzxsts8FmBk6YagalfqG1UIygGPQOMlQ78579jUUANCjM3wJOW / GJGewfEAcxDonLkfYQLz0XkOFDJaHqxcjkHg29SqD2 + C96YuQm / nAnU6RJU6Oiurbn5TKAyWQ4 // k2DxztDjiYsexLtgI0ZdZNwCbyZCegeawRuHQ+/HeejeUsSNVqEODcp3pEplTMkPj1v5mUl5PNS5wAL5Q+DJOaqGEBO44hqc+398sTyXo+fcgw93XNl1S7PuS5caiNUvkg87IdK0Q7P2zcs69ENV5ofCFiIdsdzO/y0GeE04ccR+jsAPlBWUPy9+bofRgH1hYRK2+aEnodDLzSKn6USzsv6X+bK1gzGo9wwtOyxZk4AcAASnpuyf3d/jLd0dUbALdhbBCclWMZ0eJGxIBwt+qumK/U6H4aFDHlfx+Mxj1zVC0n/2TlfSpHobKxFLpyPEjTFe3BxwVyBxJECbfycI89MgYtofzbB5wYC2ri8PQSR0qG/ZqJV3gmfOHdfXBJvUk99RDmaAN86H+BkW3yLjQ== Generated By Termius
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ec2 -
    100 - 26 - 48 - 143.compute-1.amazonaws.com ec2 - user reece — Today at 6 : 29 PM mongodb :           //<username>:<password>@<hostname>:<port>/<database>
                                                                                                mongodb : // admin:password@ec2-34-56-78-90.compute.amazonaws.com:27017/mydatabase
                                                                                                          reece — Today at 6 : 43 PM -
                                                                                                          documentation
                                                                                                              Collin Kruger — Today at 6 : 49 PM
                                                                                                                  Image
#include <Wire.h>
#include "MAX30105.h"
#include <vector>

                                                                                                                      MAX30105 particleSensor;
int led = D7;                                 // On-board LED pin
std::vector<float> store;                     // Stores offline values
String receivedString = "";                   // Stores the received string
bool WasOffline = false;                      // Tracks if the device was offline
float StartHour = 6;                          // Start of operating hours
float EndHour = 22;                           // End of operating hours
int TimeFor = 30000;                          // Time Between scans
float timeH;                                  // Temp Time Hour
unsigned long HourCont = millis() + 86400000; // Timer to keep track of the hour for clearing storage
unsigned long startTime = 0;                  // Timer for current state

// States for the state machine
enum State
{
    CHECK_CONDITIONS,
    MEASURE_DATA,
    PUBLISH_DATA,
    WAIT_INTERVAL
};

State currentState = CHECK_CONDITIONS; // Initial state

// Function to break up the incoming string
int storeString(String data)
{
    receivedString = data;
    Serial.println("Received string: " + receivedString);
    int start = 0;
    int end = data.indexOf(':');

    StartHour = data.substring(start, end).toInt();
    start = end + 1;
    end = data.indexOf(':', start);

    EndHour = data.substring(start, end).toInt();
    start = end + 1;

    TimeFor = data.substring(start).toInt();
    return 1;
}

void setup()
{
    pinMode(led, OUTPUT);
    Serial.begin(9600);
    Serial.println("Initializing MAX30105...");
    Particle.variable("storedString", receivedString);
    Particle.function("storeString", storeString);

    if (!particleSensor.begin(Wire, I2C_SPEED_STANDARD))
    {
        Serial.println("MAX30105 was not found. Please check wiring/power.");
        while (1)
            ;
    }

    particleSensor.setup();
}

void loop()
{
    switch (currentState)
    {
    case CHECK_CONDITIONS:
    {
        // for timezone
        timeH = Time.hour() - 7;
        if (timeH < 0)
        {
            timeH += 24;
        }
        else if (timeH >= 24)
        {
            timeH -= 24;
        }
        timeH += (float(Time.minute()) / 100);
        Serial.println(timeH);

        if (StartHour < timeH && EndHour > timeH)
        {
            currentState = MEASURE_DATA;
            startTime = millis(); // sets the timer
        }
        break;
    }

    case MEASURE_DATA:
    {
        // Measure ir and red values
        float irValue = particleSensor.getIR();
        float redValue = particleSensor.getRed();
        float temp1 = (irValue / 1831); // Convert ir value
        ...(131 lines left)
            Collapse
                test.ino 7 KB
                    Collin Kruger — Today at 8 : 11 PM
                        Image
﻿
#include <Wire.h>
#include "MAX30105.h"
#include <vector>

            MAX30105 particleSensor;
        int led = D7;                                 // On-board LED pin
        std::vector<float> store;                     // Stores offline values
        String receivedString = "";                   // Stores the received string
        bool WasOffline = false;                      // Tracks if the device was offline
        float StartHour = 6;                          // Start of operating hours
        float EndHour = 22;                           // End of operating hours
        int TimeFor = 30000;                          // Time Between scans
        float timeH;                                  // Temp Time Hour
        unsigned long HourCont = millis() + 86400000; // Timer to keep track of the hour for clearing storage
        unsigned long startTime = 0;                  // Timer for current state

        // States for the state machine
        enum State
        {
            CHECK_CONDITIONS,
            MEASURE_DATA,
            PUBLISH_DATA,
            WAIT_INTERVAL
        };

        State currentState = CHECK_CONDITIONS; // Initial state

        // Function to break up the incoming string
        int storeString(String data)
        {
            receivedString = data;
            Serial.println("Received string: " + receivedString);
            int start = 0;
            int end = data.indexOf(':');

            StartHour = data.substring(start, end).toInt();
            start = end + 1;
            end = data.indexOf(':', start);

            EndHour = data.substring(start, end).toInt();
            start = end + 1;

            TimeFor = data.substring(start).toInt();
            return 1;
        }

        void setup()
        {
            pinMode(led, OUTPUT);
            Serial.begin(9600);
            Serial.println("Initializing MAX30105...");
            Particle.variable("storedString", receivedString);
            Particle.function("storeString", storeString);

            if (!particleSensor.begin(Wire, I2C_SPEED_STANDARD))
            {
                Serial.println("MAX30105 was not found. Please check wiring/power.");
                while (1)
                    ;
            }

            particleSensor.setup();
        }

        void loop()
        {
            switch (currentState)
            {
            case CHECK_CONDITIONS:
            {
                // for timezone
                timeH = Time.hour() - 7;
                if (timeH < 0)
                {
                    timeH += 24;
                }
                else if (timeH >= 24)
                {
                    timeH -= 24;
                }
                timeH += (float(Time.minute()) / 100);
                Serial.println(timeH);

                if (StartHour < timeH && EndHour > timeH)
                {
                    currentState = MEASURE_DATA;
                    startTime = millis(); // sets the timer
                }
                break;
            }

            case MEASURE_DATA:
            {
                // Measure ir and red values
                float irValue = particleSensor.getIR();
                float redValue = particleSensor.getRed();
                float temp1 = (irValue / 1831);  // Convert ir value
                String temp2 = String(redValue); // Placeholder for red value
                String timestamp = getMSTTimestamp();

                // run the loop until temp1 exceeds 40 bpm or 5 minutes have passed
                while (temp1 < 40 && millis() - startTime < 300000)
                {
                    irValue = particleSensor.getIR();   // read ir value
                    redValue = particleSensor.getRed(); // read red led value
                    temp1 = (irValue / 1831);
                    temp2 = String(redValue);
                    digitalWrite(led, HIGH);
                    delay(250);
                    digitalWrite(led, LOW);
                    delay(250);
                }

                if (temp1 > 40)
                {
                    currentState = PUBLISH_DATA;
                }
                else
                {
                    currentState = WAIT_INTERVAL;
                }
                break;
            }

            case PUBLISH_DATA:
            {
                float temp1 = 0;
                float temp2 = 0;

                // measure and average ir and red values
                for (int i = 0; i < 21; i++)
                {
                    float irValue = particleSensor.getIR();
                    float redValue = particleSensor.getRed();
                    temp1 += irValue;
                    temp2 += redValue;
                }
                temp1 = (temp1 / 20) / 1831;
                temp2 = (temp2 / 20) / 65535.0;
                String timestamp = getMSTTimestamp(); // get timestamp

                if (WiFi.ready())
                {
                    // send all offline values if the device was offline
                    if (WasOffline)
                    {
                        for (int i = 0; i < store.size(); i++)
                        {
                            String Send_Data = "{\"TEMP1\":" + String(store.at(i)) + ",\"TEMP2\":" + temp2 + ",\"TEMP3\":\"" + timestamp + "\"}";
                            Particle.publish("temp", Send_Data, PRIVATE);
                        }
                        WasOffline = false;
                    }

                    // publish data
                    String Send_Data = "{\"TEMP1\":" + String(temp1) + ",\"TEMP2\":" + temp2 + ",\"TEMP3\":\"" + timestamp + "\"}";
                    Particle.publish("temp", Send_Data, PRIVATE);
                    Serial.print("ir: ");
                    Serial.println(temp1);
                    Serial.print("red: ");
                    Serial.println(temp2);
                    Serial.print("time: ");
                    Serial.println(timestamp);
                }
                else
                {
                    // store data offline for 24 hours
                    if (millis() - HourCont < 86400000)
                    {
                        store.push_back(temp1);
                        WasOffline = true;
                    }
                    else
                    {
                        HourCont = millis();
                        store.clear();
                    }
                    Serial.println("Wi-Fi not connected, data stored offline.");
                }

                currentState = WAIT_INTERVAL;
                break;
            }

            case WAIT_INTERVAL:
            {
                // Wait for next meserment
                delay(TimeFor);
                currentState = CHECK_CONDITIONS;
                break;
            }
            }
        }

        // get MST timestamp
        String getMSTTimestamp()
        {
            int year = Time.year();
            int month = Time.month();
            int day = Time.day();
            int hour = Time.hour();
            int minute = Time.minute();
            int second = Time.second();

            hour -= 7;
            if (hour < 0)
            {
                hour += 24;
                day -= 1;
                if (day < 1)
                {
                    month -= 1;
                    if (month < 1)
                    {
                        month = 12;
                        year -= 1;
                    }
                    switch (month)
                    {
                    case 1:
                    case 3:
                    case 5:
                    case 7:
                    case 8:
                    case 10:
                    case 12:
                        day = 31;
                        break;
                    case 4:
                    case 6:
                    case 9:
                    case 11:
                        day = 30;
                        break;
                    }
                }
            }

            return (String(year) + "-" + String(month) + "-" + String(day) + " " + String(hour) + ":" + String(minute) + ":" + String(second));
        }

        test.ino 7 KB